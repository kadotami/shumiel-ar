<!DOCTYPE html>
<html>
<head>
<script src="jquery.js"></script>
<script src="https://aframe.io/releases/0.5.0/aframe.min.js"></script>
<script src="https://jeromeetienne.github.io/AR.js/aframe/build/aframe-ar.js"></script>
</head>
<body>
<script>
    var prepare_ar = function() {
        var modelPath = 'model/test.json'; 

        var renderer	= new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
        });
        renderer.setClearColor(new THREE.Color('lightgrey'), 0)
        renderer.setSize( 640, 480 );
        renderer.domElement.style.position = 'absolute'
        renderer.domElement.style.top = '0px'
        renderer.domElement.style.left = '0px'
        document.body.appendChild( renderer.domElement );


        var onRenderFcts= [];
        var scene	= new THREE.Scene();

        var camera = new THREE.Camera();
        scene.add(camera);

        var arToolkitSource = new THREEx.ArToolkitSource({
            sourceType : 'webcam'
        })

        arToolkitSource.init(function onReady(){
            onResize()
        })
        
        // handle resize
        window.addEventListener('resize', function(){
            onResize()
        })
        function onResize(){
            arToolkitSource.onResize()	
            arToolkitSource.copySizeTo(renderer.domElement)	
            if( arToolkitContext.arController !== null ){
                arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)	
            }	
        }

        // create atToolkitContext
        var arToolkitContext = new THREEx.ArToolkitContext({
            cameraParametersUrl: THREEx.ArToolkitContext.baseURL + '../data/data/camera_para.dat',
            detectionMode: 'mono',
        })
        // initialize it
        arToolkitContext.init(function onCompleted(){
            // copy projection matrix to camera
            camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
        })

        // update artoolkit on every frame
        onRenderFcts.push(function(){
            if( arToolkitSource.ready === false )	return

            arToolkitContext.update( arToolkitSource.domElement )
            
            // update scene.visible if the marker is seen
            scene.visible = camera.visible
        })

        var markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
            type : 'pattern',
            patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.hiro',
            // patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.kanji',
            // as we controls the camera, set changeMatrixMode: 'cameraTransformMatrix'
            changeMatrixMode: 'cameraTransformMatrix'
        })
        // as we do changeMatrixMode: 'cameraTransformMatrix', start with invisible scene
        scene.visible = false

        // light
        var directionalLight = new THREE.DirectionalLight(0xFFFFCD, 0.8);　　
        directionalLight.position.set(0, 60, 200);　　
        var ambientLight = new THREE.AmbientLight(0xFFFFCD);　　
        scene.add(directionalLight, ambientLight);

        loader = new THREE.JSONLoader();　　
        loader.load(modelPath, function(geo, mat) {　　　
            var faceMat = new THREE.MeshFaceMaterial(mat);　　　
            var model = new THREE.Mesh(geo, faceMat);　　　
            model.position.set(0, 0, 0);　　　
            model.scale.set(0.5, 0.5, 0.5);　　　
            scene.add(model);　　　
        });　　

        
        // onRenderFcts.push(function(delta){
        //     mesh.rotation.x += Math.PI*delta
        // })


        onRenderFcts.push(function(){
            renderer.render( scene, camera );
        })

        // run the rendering loop
        var lastTimeMsec= null
        requestAnimationFrame(function animate(nowMsec){
            // keep looping
            requestAnimationFrame( animate );
            // measure time
            lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
            var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
            lastTimeMsec	= nowMsec
            // call each update function
            onRenderFcts.forEach(function(onRenderFct){
                onRenderFct(deltaMsec/1000, nowMsec/1000)
            });
        });
    }

    var getUrlVars = function(){
        var vars = {};
        var param = location.search.substring(1).split('&');
        for(var i = 0; i < param.length; i++) {
            var keySearch = param[i].search(/=/);
            var key = '';
            if(keySearch != -1) key = param[i].slice(0, keySearch);
            var val = param[i].slice(param[i].indexOf('=', 0) + 1);
            if(key != '') vars[key] = decodeURI(val);
        }
        return vars;
    }
    var getVal = getUrlVars();
    var token = getVal["token"];

    $.ajax({
      type: 'POST',
      url: 'http://133.130.127.250:5000/word2vec/category',
      data: {
        "query": "睡眠"
      },
      headers: {
        'Content-Type': 'application/json',
        'Authorization': token
      },
      traditional: true,
      dataType: 'json'
    }).done(function(data){
      console.log(data);
      prepare_ar();
    });
</script>
</body>
</html>